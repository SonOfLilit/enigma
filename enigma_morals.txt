מה למדתי עד כה מתרגיל אניגמה?
תכנון היררכי של תוכנית (קליטת אות, עיבוד אות, פליטת אות).
נחמד שהמידע יושב במילון. לא צריך כל הזמן return.
מילון בתוך מילון - יכול להיות כלי לשלוף דברים. אני רוצה לשלוף את wheel_n כתלות ב- n. זה לא הולך. אבל wheels[n] כן עובד.
דיבאגגינג. להתסכל שלב שלב.
איפה שיש חשבון מודלרי עדיף לעבוד עם המספר 0 בתור הבסיס (ולא להסיט).
ביקורת קלט - לא להרשות כל דבר אפילו אם זה עובד. עדיף לחתוך את הטעויות קטנות.
פונקציה שהופכת מילונים.
כל המצב צריך להיות ב- state יחיד, מילון יחיד. לא דוחפים את היסט הגלגל למילון הגלגל עצמו!
הכנה ללולאות במקרה ויש הרבה גלגלים.

סיבוב שני
--------
אין בפייתון חיפוש הפוך במילונים. צריך באופן "ידני".
מה אני רוצה לעשות היום:
1) עובד על קובץ
2) עוד גלגלים
3) מקבל מפתח - באיזה גלגלים נעשה שימוש ואיפה הם מוצבים, ומהן ההסטות הבסיסיות שלהן.


הערות של עמוס:
1) גלגלים עדיף כרשימה ולא כמילון.
2) במילון מעדיפים שכל המפתחות יהיו מאותו סוג.
מהות אחת למפתחות, מהות אחת לערכים. מה עושים אם התוצאה?
3) קבועים - אותיות גדולות.
4) list comprehension.
ALPHABET = [chr(i) for i in xrange(ord('a'),ord('d')+1)]
5) state - להפוך למחלקה.
6) האות המוצפנת אינה חלק ב- state.
7) הפרדה רעיונית לשני חלקים: קלט+פלט, לב (האניגמה).
8) רעיון - להפוך גלגל לאובייקט. הוא מסובב את עצמו, יודע להצפין ויודע להצפין הפוך.
9) לחשוב איך המערכת הפיזית בנויה - אילו אובייקטים יש. למשל:
יש גלגל שיודע להצפין, הפוך, ויש לו היסט.
למכונה יש גלגלים, והיא שמה אותם במיקומים מסוימים.
יש מערכת קלט + פלט והיא עוטפת את המערכת של הליבה.

אולי לעבור ל- C
שלבים בקומפילציה של C.